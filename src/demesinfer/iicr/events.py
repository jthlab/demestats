from dataclasses import dataclass
from functools import partial, reduce

import diffrax as dfx
import equinox as eqx
import jax
import jax.numpy as jnp
import numpy as np
from jaxtyping import Array, Float, Scalar, ScalarLike
from loguru import logger

import demesinfer.events as base
import demesinfer.util as util
from demesinfer.path import Path, get_path

from .interp import PanmicticInterpolator
from .migration import lift_migration, lift_migration_const
from .state import SetupReturn, State, StateReturn

NoOp = base.NoOp
Epoch = base.Epoch


def setup_lift(
    state: None, t0: Path, t1: Path, terminal: bool, aux: dict, demo: dict
) -> tuple[None, dict]:
    const = dict(util.constant_growth_in(demo, t0, t1))
    return None, dict(const=const, migrations=list(util.migrations_in(demo, t0, t1)))


def lift(
    state: State, t0: Path, t1: Path, terminal: bool, demo: dict, aux: dict
) -> StateReturn:
    """Lift partial likelihood.

    Args:
        state: state just before the lifting event
        t0: time before the lifting event
        t1: time after the lifting event
        terminal: does lift go to infinity?
        demo: dict of parameters
        aux: dict of auxiliary data generated by setup

    Returns:
        State after the lifting event.
    """
    logger.debug("lift: state={} t0={} t1={} terminal={}", state, t0, t1, terminal)
    t0 = jnp.array(get_path(demo, t0))
    t1 = jnp.array(get_path(demo, t1))

    n = state.p.ndim
    d = len(state.pops)
    assert state.p.shape == (d + 1,) * n, (
        f"Expected shape {(d + 1,) * n}, got {state.p.shape}"
    )
    inds = np.transpose(np.unravel_index(np.arange((d + 1) ** n), (d + 1,) * n))
    counts = jax.vmap(lambda b: jnp.bincount(b, length=d + 1))(inds).reshape(
        (d + 1,) * n + (d + 1,)
    )
    C = counts * (counts - 1) / 2
    active_migr = [m for m in aux["migrations"] if set(m) & set(state.pops)]

    if len(active_migr) == 0 or terminal:
        interp = PanmicticInterpolator(state=state, t0=t0, t1=t1, C=C)
        d1 = interp(t1, demo)
        state = state._replace(log_s=d1["log_s"], p=d1["p"])
        return state, {"lift": interp}

    const = all(aux["const"].get(p, False) for p in state.pops)
    lm = lift_migration_const

    if not const:
        logger.info(
            "Using ODE solver for migration and non-constant size. This may be slow."
        )
        lm = lift_migration

    return lm(state, t0, t1, terminal, demo, aux, C)


@dataclass(kw_only=True)
class PopulationStart(base.PopulationStart):
    pass


@dataclass(kw_only=True)
class Split1(base.Split1):
    def __call__(self, demo: dict, aux: dict, child_state: State) -> StateReturn:
        pops = child_state.pops
        assert self.donor in pops
        assert self.recipient in pops
        lst = list(pops)
        j = lst.index(self.donor)
        lst.pop(j)  # remove the donor from the axes
        k = lst.index(self.recipient)
        pops = tuple(lst)
        p_prime = _merge(child_state.p, j, k)
        return child_state._replace(pops=pops, p=p_prime), {}


@dataclass(kw_only=True)
class Split2(base.Split2):
    def __call__(
        self, demo: dict, aux: dict, donor_state: State, recipient_state: State
    ) -> StateReturn:
        """Merge two populations in different event blocks.

        Args:
            st: state just before the merge event
            demo: dict of parameters
            aux: dict of auxiliary data generated by setup
        """
        p_prime = _product(recipient_state.p, donor_state.p)
        # now want to merge the populations in donor and recip into one
        combined_pops = recipient_state.pops + donor_state.pops
        j, k = [list(combined_pops).index(x) for x in (self.donor, self.recipient)]
        p_prime = _merge(p_prime, j, k)
        cp = list(combined_pops)
        cp.remove(self.donor)
        return State(
            p=p_prime,
            pops=tuple(cp),
            log_s=donor_state.log_s + recipient_state.log_s,
        ), {}


@dataclass(kw_only=True)
class Merge(base.Merge):
    def __call__(
        self, demo: dict, aux: dict, pop1_state: State, pop2_state
    ) -> StateReturn:
        # merge the two population tensors into one
        # an empty/scalar tensor represents one deme with no lineages
        p_prime = _product(pop1_state.p, pop2_state.p)
        return State(
            p=p_prime,
            pops=pop1_state.pops + pop2_state.pops,
            log_s=pop1_state.log_s + pop2_state.log_s,
        ), {}


@dataclass(kw_only=True)
class MigrationStart(base.MigrationStart):
    def __call__(self, demo: dict, aux: dict, child_state: State) -> StateReturn:
        return child_state, {}


@dataclass(kw_only=True)
class MigrationEnd(base.MigrationEnd):
    def __call__(self, demo: dict, aux: dict, child_state: State) -> StateReturn:
        return child_state, {}


@dataclass(kw_only=True)
class Admix(base.Admix):
    def __call__(self, demo: dict, aux: dict, child_state: State) -> StateReturn:
        p_admix = self.prop_fun(demo)
        # child splits into self.parent1 and self.parent2
        pops = list(child_state.pops)
        i = pops.index(self.child)
        pops.pop(i)
        pops.extend([self.parent1, self.parent2])
        n = len(pops)
        p_prime = _split(child_state.p, i, n - 2, n - 1, p_admix)
        return child_state._replace(p=p_prime, pops=tuple(pops)), {}


@dataclass(kw_only=True)
class Pulse(base.Pulse):
    def __call__(self, demo: dict, aux: dict, child_state) -> StateReturn:
        p_pulse = self.prop_fun(demo)
        pops = list(child_state.pops)
        i = pops.index(self.dest)
        j = pops.index(self.source)
        p_prime = _pulse(child_state.p, i, j, p_pulse)
        return child_state._replace(p=p_prime), {}


def _merge(p, j, k):
    "merge population j into population k"

    # this means merge tensor indices j into k along each axis
    def f(q, i):
        def g(v):
            return jnp.delete(v, j).at[k].add(v[j])

        return jnp.apply_along_axis(g, i, q)

    return reduce(f, range(p.ndim), p)


def _split(p, j, k1, k2, prob):
    "split population j into populations k1 and k2"
    if k1 > k2:
        return _split(p, j, k2, k1, 1 - prob)

    def f(q, i):
        def g(v):
            vj = v[j]
            v = jnp.delete(v, j)
            v = jnp.insert(v, k1, vj * prob)
            v = jnp.insert(v, k2, vj * (1 - prob))
            return v

        return jnp.apply_along_axis(g, i, q)

    ret = reduce(f, range(p.ndim), p)
    return ret


def _pulse(p, j, k, prob):
    "pulse population j into population k"

    def f(q, i):
        def g(v):
            return v.at[j].multiply(1 - prob).at[k].add(v[j] * prob)

        return jnp.apply_along_axis(g, i, q)

    return reduce(f, range(p.ndim), p)


def _product(p1, p2):
    # align two ndarrays for concatenation
    n = p1.ndim
    assert n == p2.ndim
    d1 = p1.shape[0] - 1
    assert p1.shape == (d1 + 1,) * n
    d2 = p2.shape[0] - 1
    assert p2.shape == (d2 + 1,) * n
    # ret = jnp.zeros((d1 + d2 + 1,) * n)
    inds = jnp.array(jnp.meshgrid(*[jnp.arange(d1 + d2 + 1)] * n, indexing="ij"))
    i1 = jnp.where(inds < d1, inds, -1)
    i2 = jnp.where((d1 <= inds) & (inds < d1 + d2), inds - d1, -1)
    p1f = p1[*i1]
    p2f = p2[*i2]
    return (p1f * p2f).reshape((d1 + d2 + 1,) * n)
