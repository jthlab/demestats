from dataclasses import dataclass
from functools import partial, reduce

import diffrax as dfx
import equinox as eqx
import jax
import jax.numpy as jnp
import numpy as np
from jaxtyping import Array, Float, Scalar, ScalarLike
from loguru import logger

import demestats.util as util
from demestats.path import Path, get_path

from .. import events as base
from . import lift
from .state import SetupState
from .state import StateDn as State

NoOp = base.NoOp
Epoch = base.Epoch


@dataclass(kw_only=True)
class PopulationStart(base.PopulationStart):
    pass


@dataclass(kw_only=True)
class Split1(base.Split1):
    def __call__(self, demo: dict, aux: dict, child_state: State) -> tuple[State, dict]:
        pops = child_state.pops
        assert self.donor in pops
        assert self.recipient in pops
        lst = list(pops)
        j = lst.index(self.donor)
        lst.pop(j)  # remove the donor from the axes
        k = lst.index(self.recipient)
        pops = tuple(lst)
        p_prime = _merge(child_state.p, j, k)
        return State(pops=pops, p=p_prime, log_s=child_state.log_s), {}


@dataclass(kw_only=True)
class Split2(base.Split2):
    def __call__(
        self, demo: dict, aux: dict, donor_state: State, recipient_state: State
    ) -> tuple[State, dict]:
        """Merge two populations in different event blocks.

        Args:
            st: state just before the merge event
            demo: dict of parameters
            aux: dict of auxiliary data generated by setup
        """
        p_prime = _product(recipient_state.p, donor_state.p)
        # now want to merge the populations in donor and recip into one
        combined_pops = recipient_state.pops + donor_state.pops
        j, k = [list(combined_pops).index(x) for x in (self.donor, self.recipient)]
        p_prime = _merge(p_prime, j, k)
        cp = list(combined_pops)
        cp.remove(self.donor)
        return State(
            p=p_prime,
            pops=tuple(cp),
            log_s=donor_state.log_s + recipient_state.log_s,
        ), {}


@dataclass(kw_only=True)
class Merge(base.Merge):
    def __call__(
        self, demo: dict, aux: dict, pop1_state: State, pop2_state
    ) -> tuple[State, dict]:
        # merge the two population tensors into one
        # an empty/scalar tensor represents one deme with no lineages
        p_prime = _product(pop1_state.p, pop2_state.p)
        cp = pop1_state.pops + pop2_state.pops
        s = State(
            p=p_prime,
            pops=cp,
            log_s=pop1_state.log_s + pop2_state.log_s,
        )
        return s, {}


@dataclass(kw_only=True)
class MigrationStart(base.MigrationStart):
    def __call__(self, demo: dict, aux: dict, child_state: State) -> tuple[State, dict]:
        return child_state, {}


@dataclass(kw_only=True)
class MigrationEnd(base.MigrationEnd):
    def __call__(self, demo: dict, aux: dict, child_state: State) -> tuple[State, dict]:
        return child_state, {}


@dataclass(kw_only=True)
class Admix(base.Admix):
    def __call__(self, demo: dict, aux: dict, child_state: State) -> tuple[State, dict]:
        p_admix = self.prop_fun(demo)
        # child splits into self.parent1 and self.parent2
        pops = list(child_state.pops)
        i = pops.index(self.child)
        pops.pop(i)
        pops.extend([self.parent1, self.parent2])
        n = len(pops)
        p_prime = _split(child_state.p, i, n - 2, n - 1, p_admix)
        return State(p=p_prime, pops=tuple(pops), log_s=child_state.log_s), {}


@dataclass(kw_only=True)
class Pulse(base.Pulse):
    def __call__(self, demo: dict, aux: dict, child_state) -> tuple[State, dict]:
        p_pulse = self.prop_fun(demo)
        pops = list(child_state.pops)
        i = pops.index(self.dest)
        j = pops.index(self.source)
        p_prime = _pulse(child_state.p, i, j, p_pulse)
        return State(p=p_prime, pops=child_state.pops, log_s=child_state.log_s), {}


@partial(jax.jit, static_argnames=("j", "k"))
def _merge(p, j, k):
    "merge population j into population k"

    # this means merge tensor indices j into k along each axis
    def f(q, i):
        def g(v):
            return jnp.delete(v, j).at[k].add(v[j])

        return jnp.apply_along_axis(g, i, q)

    return reduce(f, range(p.ndim), p)


@jax.jit
def _split(p, j, k1, k2, prob):
    "split population j into populations k1 and k2"
    if k1 > k2:
        return _split(p, j, k2, k1, 1 - prob)

    def f(q, i):
        def g(v):
            vj = v[j]
            v = jnp.delete(v, j)
            v = jnp.insert(v, k1, vj * prob)
            v = jnp.insert(v, k2, vj * (1 - prob))
            return v

        return jnp.apply_along_axis(g, i, q)

    ret = reduce(f, range(p.ndim), p)
    return ret


@jax.jit
def _pulse(p, j, k, prob):
    "pulse population j into population k"

    def f(q, i):
        def g(v):
            return v.at[j].multiply(1 - prob).at[k].add(v[j] * prob)

        return jnp.apply_along_axis(g, i, q)

    return reduce(f, range(p.ndim), p)


@jax.jit
def _product(p1, p2):
    # align two ndarrays for concatenation
    n = p1.ndim
    assert n == p2.ndim
    d1 = p1.shape[0] - 1
    assert p1.shape == (d1 + 1,) * n
    d2 = p2.shape[0] - 1
    assert p2.shape == (d2 + 1,) * n
    # ret = jnp.zeros((d1 + d2 + 1,) * n)
    inds = jnp.array(jnp.meshgrid(*[jnp.arange(d1 + d2 + 1)] * n, indexing="ij"))
    i1 = jnp.where(inds < d1, inds, -1)
    i2 = jnp.where((d1 <= inds) & (inds < d1 + d2), inds - d1, -1)
    p1f = p1[*i1]
    p2f = p2[*i2]
    return (p1f * p2f).reshape((d1 + d2 + 1,) * n)
