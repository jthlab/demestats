"""Merge two populations in different event blocks"""

from copy import deepcopy
from dataclasses import dataclass

import jax.numpy as jnp
import numpy as np
from penzai import pz

import demestats.events as base
from demestats.util import log_hypergeom, unique_strs

from .state import SetupReturn, SetupState, State, StateReturn


@dataclass(kw_only=True)
class Split2(base.Split2):
    """Merge two populations in different event blocks.

    Attributes:
        donor: the population which donates alleles into the recipient (backwards in time)
        recipient: the population which receives allels from the donor

    Notes:
        After the merge, the donor population is removed from the partial likelihood.
    """

    def setup(
        self,
        demo: dict,
        aux: dict,
        donor_state: SetupState,
        recipient_state: SetupState,
    ) -> SetupReturn:
        donor_axes = donor_state.axes
        recip_axes = recipient_state.axes
        nw1 = donor_axes[self.donor] - 1
        nw2 = recip_axes[self.recipient] - 1
        n = nw1 + nw2
        x1, x2, x = np.ogrid[: nw1 + 1, : nw2 + 1, : n + 1]
        H = np.exp(log_hypergeom(n=nw1, k=x1, M=n, N=x)) * (
            x == x1 + x2
        )  # shape = (nw1+1, nw2+1, nv+1)
        (tmp,) = unique_strs(list(donor_axes) + list(recip_axes))
        # construct axes
        assert not (
            donor_axes.keys() & recip_axes.keys()
        )  # the axes should be disjoint if we are using this event
        out_axes = donor_axes | recip_axes
        out_axes[self.recipient] += out_axes[self.donor] - 1
        del out_axes[self.donor]
        aux = {
            "H": H,
            "tmp": tmp,
            "out_axes": out_axes,
        }
        # determine number of lineages subtended by resulting pops
        mig = donor_state.migrations | recipient_state.migrations
        nsp = deepcopy(donor_state.ns) | deepcopy(recipient_state.ns)
        nsp[self.recipient].update(nsp[self.donor])
        del nsp[self.donor]
        stp = SetupState(
            ns=nsp,
            axes=out_axes,
            migrations=mig,
        )
        return stp, aux

    def __call__(
        self, demo: dict, aux: dict, donor_state: State, recipient_state: State
    ) -> StateReturn:
        """Merge two populations in different event blocks.

        Args:
            pop1_st: state of pop1 before the merge
            pop2_st: state of pop2 before the merge
            pd: dict of parameters, unused.
            aux: dict of auxiliary data generated by setup

        Notes:
            pop2 is merged into pop1. The merged population resides in axis 0.
        """

        @pz.nx.nmap
        def f(T1, T2):
            return jnp.einsum("i,j,ijk->k", T1, T2, aux["H"])

        plp = f(
            donor_state.pl.untag(self.donor),
            recipient_state.pl.untag(self.recipient),
        ).tag(self.recipient)
        phip = (
            donor_state.phi * recipient_state.l0 + recipient_state.phi * donor_state.l0
        )
        return State(pl=plp, phi=phip, l0=donor_state.l0 * recipient_state.l0), {}
