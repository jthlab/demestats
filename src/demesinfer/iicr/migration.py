from functools import partial
from typing import Callable

import diffrax as dfx
import equinox as eqx
import jax
import jax.numpy as jnp
from jaxtyping import Array, Float, ScalarLike
from loguru import logger

import demesinfer.util as util

from .interp import ODEInterpolator
from .state import State, StateReturn


def lift_migration_const(
    state: State,
    t0: ScalarLike,
    t1: ScalarLike,
    terminal: bool,
    demo: dict,
    aux: dict,
    C: Float[Array, "..."],
):
    logger.debug("Constant size with migration not implemented yet.")
    return lift_migration(state, t0, t1, terminal, demo, aux, C)


def lift_migration(
    state: State,
    t0: ScalarLike,
    t1: ScalarLike,
    terminal: bool,
    demo: dict,
    aux: dict,
    C: Float[Array, "..."],
) -> StateReturn:
    """Lift partial likelihood.

    Args:
        st: state just before the lifting event
        demo: dict of parameters
        aux: dict of auxiliary data generated by setup

    Returns:
        State after the lifting event.
    """
    aux = aux or {}
    n = state.p.ndim

    etas = util.coalescent_rates(demo)
    mu = partial(util.migration_rate, demo)

    def rate(t):
        eta = jnp.array([1 / 2 / etas[pop](t) for pop in state.pops])
        eta = jnp.append(eta, 0.0)
        return C.dot(eta)

    def f(t, y, args):
        # migration matrix at time t
        M_t = jnp.array(
            [[mu(dest, src, t) for dest in state.pops] for src in state.pops]
        )
        M_t = jnp.pad(M_t, ((0, 1), (0, 1)), constant_values=0.0)  # add untracked deme
        M_t = M_t - jnp.diag(M_t.sum(axis=1))  # make it a stochastic matrix
        # transition p forward in time
        p, s = y
        ds = p * rate(t)
        # multiply along each axis, equivalent of direct sum
        dp = sum(
            map(
                lambda i: jnp.apply_along_axis(M_t.T.__matmul__, i, p),
                range(n),
            )
        )
        # movement into coalescent state
        dp -= ds  # movement among migrant states, independent
        return dp, ds.sum()

    solver = dfx.Dopri5()
    term = dfx.ODETerm(f)
    eta_ts = jnp.concatenate([eta.t[:-1] for eta in etas.values()])
    mu_ts = jnp.array(
        [m.get(x, t0) for m in demo["migrations"] for x in ("start_time", "end_time")]
    )
    jump_ts = jnp.concatenate([eta_ts, mu_ts])
    jump_ts = jnp.sort(jump_ts)
    saveat = dfx.SaveAt(dense=True, t1=True)
    # FIXME using jump_ts causes nans to be returned
    ssc = dfx.PIDController(rtol=1e-4, atol=1e-4, jump_ts=jump_ts)
    y0 = (state.p, 0.0)

    # if f has error, this will throw more comprehensibly than doing it inside of diffeqsolve
    args = None
    y1 = f(t0, y0, args)
    sol = dfx.diffeqsolve(
        term,
        solver,
        t0=t0,
        t1=t1,
        dt0=(t1 - t0) / 1000,
        args=args,
        y0=y0,
        stepsize_controller=ssc,
        saveat=saveat,
    )
    p1 = sol.ys[0][0]
    s1 = sol.ys[1][0]
    p1 = p1 / p1.sum()  # normalize to probability conditional on non-coalescence

    state = state._replace(
        p=p1,
        log_s=state.log_s + jnp.log1p(-s1),
    )

    interp = ODEInterpolator(sol=sol, state=state, t0=t0, t1=t1, C=C, jump_ts=jump_ts)

    return state, {"lift": interp}
