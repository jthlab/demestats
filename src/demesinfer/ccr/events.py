from dataclasses import dataclass

import jax
import jax.numpy as jnp
from penzai import pz

from ..iicr import events as base
from ..iicr.nd.events import admix_helper, split1_helper
from .state import StateCcr as State

NoOp = base.NoOp
Epoch = base.Epoch


@dataclass(kw_only=True)
class PopulationStart(base.PopulationStart):
    pass


@dataclass(kw_only=True)
class Split1(base.Split1):
    def __call__(self, demo: dict, aux: dict, child_state: State) -> tuple[State, dict]:
        """Merge two populations in same event blocks.

        Args:
            st: state just before the merge event
            demo: dict of parameters
            aux: dict of auxiliary data generated by setup
        """
        pops = child_state.pops
        assert self.donor in pops
        assert self.recipient in pops

        p_prime = child_state.p
        for color in ("red", "blue"):
            p_prime = p_prime.untag((self.donor, color), (self.recipient, color))
            p_prime = split1_helper(p_prime)
            p_prime = p_prime.tag((self.recipient, color))
        return State(p=p_prime, log_s=child_state.log_s), {}


@dataclass(kw_only=True)
class Split2(base.Split2):
    def __call__(
        self, demo: dict, aux: dict, donor_state: State, recipient_state: State
    ) -> tuple[State, dict]:
        """Merge two populations in different event blocks.

        Args:
            st: state just before the merge event
            demo: dict of parameters
            aux: dict of auxiliary data generated by setup
        """
        n = donor_state.p.named_shape[(self.donor, "red")]
        assert recipient_state.p.named_shape[(self.recipient, "red")] == n
        assert donor_state.p.named_shape[(self.donor, "blue")] == n
        assert recipient_state.p.named_shape[(self.recipient, "blue")] == n

        @pz.nx.nmap
        def f(donor_col, recip_col):
            return jnp.convolve(donor_col, recip_col, mode="full")[:n]

        pd = donor_state.p.untag((self.donor, "red"))
        pr = recipient_state.p.untag((self.recipient, "red"))
        p_prime = f(pd, pr).tag((self.recipient, "red"))

        # now do blue, but the pops have been merged
        p_prime = p_prime.untag((self.donor, "blue"), (self.recipient, "blue"))
        p_prime = split1_helper(p_prime)
        p_prime = p_prime.tag((self.recipient, "blue"))

        return State(
            p=p_prime,
            log_s=donor_state.log_s + recipient_state.log_s,
        ), {}


@dataclass(kw_only=True)
class Merge(base.Merge):
    def __call__(
        self, demo: dict, aux: dict, pop1_state: State, pop2_state: State
    ) -> tuple[State, dict]:
        # pops must be disjoint
        assert pop1_state.p.named_axes.keys().isdisjoint(pop2_state.p.named_axes.keys())
        ax1 = list(pop1_state.p.named_axes)
        ax2 = list(pop2_state.p.named_axes)
        n = pop1_state.p.named_axes[ax1[0]]
        assert all(pop1_state.p.named_axes[a] == n for a in ax1)
        assert all(pop2_state.p.named_axes[a] == n for a in ax2)
        p_prime = pop1_state.p * pop2_state.p
        return State(
            p=p_prime,
            log_s=pop1_state.log_s + pop2_state.log_s,
        ), {}


@dataclass(kw_only=True)
class MigrationStart(base.MigrationStart):
    def __call__(self, demo: dict, aux: dict, child_state: State) -> tuple[State, dict]:
        return child_state, {}


@dataclass(kw_only=True)
class MigrationEnd(base.MigrationEnd):
    def __call__(self, demo: dict, aux: dict, child_state: State) -> tuple[State, dict]:
        return child_state, {}


@dataclass(kw_only=True)
class Admix(base.Admix):
    def __call__(self, demo: dict, aux: dict, child_state: State) -> tuple[State, dict]:
        p_admix = self.prop_fun(demo)
        p_prime = child_state.p
        for color in ("red", "blue"):
            p_prime = p_prime.untag((self.child, color))
            p_prime = admix_helper(p_prime, p_admix)
            p_prime = p_prime.tag((self.parent1, color), (self.parent2, color))
        return State(p=p_prime, log_s=child_state.log_s), {}


@dataclass(kw_only=True)
class Pulse(base.Pulse):
    def __call__(self, demo: dict, aux: dict, child_state) -> tuple[State, dict]:
        p_pulse = self.prop_fun(demo)
        n = child_state.n
        # p'[i,j] = \sum_{u,v,w} p[u,v] * binom(w; u, p) * (u - w == i) * (v + w == j)
        i, u, w = jnp.ogrid[: n + 1, : n + 1, : n + 1]
        B = jax.scipy.stats.binom.pmf(w, u, p_pulse)[0]  # strip i dimension
        uwi = u - w == i

        @pz.nx.nmap
        def f(P):
            return jnp.einsum("uv,uw,iuw,vjw->ij", P, B, uwi, uwi)

        p_prime = child_state.p
        for color in ("red", "blue"):
            pu = p_prime.untag((self.dest, color), (self.source, color))
            p_prime = f(pu).tag((self.dest, color), (self.source, color))

        return State(p=p_prime, log_s=child_state.log_s), {}
