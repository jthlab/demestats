"""Lift an event backwards in time"""

import itertools as it
import math
from copy import deepcopy
from dataclasses import dataclass
from fractions import Fraction as mpq
from functools import lru_cache, partial
from typing import Any

import networkx as nx
import numpy as np
import scipy
from jax import lax, vmap
from jax import numpy as jnp
from jax.scipy.linalg import expm
from jaxtyping import Array, ArrayLike, Float, Int, Scalar, ScalarLike
from penzai import pz

import demesinfer.events as base
import demesinfer.util as util
from demesinfer.coal_rate import CoalRate
from demesinfer.path import Path, get_path
from demesinfer.pexp import PExp

from ..migration import lift_cm, lift_cm_aux
from .state import *


def aux_single(nv):
    if nv == 0:
        return
    d, Q = moran_eigensystem(nv)
    M = rate_matrix(nv).toarray()
    QQ, RR = jnp.linalg.qr(Q)
    W = W_matrix(nv).astype(float)
    return dict(d=d, Q=Q, M=M, W=W, QQ=QQ, RR=RR)


def setup_lift(
    state: SetupState, t0: Path, t1: Path, terminal: bool, aux: dict, demo: dict
) -> SetupReturn:
    """Compute the matrices needed for lifting."""
    if terminal:
        assert len(state.axes) == 1

    G = nx.DiGraph()
    G.add_nodes_from(
        state.axes
    )  # add a node for each population in the child partial likelihood
    # only consider migrations between axes that actually exist
    for pop1, pop2 in util.migrations_in(demo, t0, t1):
        x = {pop1, pop2}
        y = set(state.axes.keys())
        assert x.isdisjoint(y) or x.issubset(y), (
            f"Migration between {pop1} and {pop2} not in child axes {state.axes}"
        )
        if pop1 in state.axes and pop2 in state.axes:
            G.add_edge(pop1, pop2)
    migration_sets = [tuple(c) for c in nx.connected_components(G.to_undirected())]
    # refine migration sets to only consider who is migrating into who
    migration_sets1 = []
    for cc in migration_sets:
        if len(cc) == 1:
            # if there is no migration, lift the single population in isolation
            migration_sets1.append(cc[0])
            continue
        a = []
        for c1, c2 in it.product(cc, repeat=2):
            if G.has_edge(c1, c2):
                a.append((c1, c2))
        migration_sets1.append(tuple(a))
    aux = {"mats": {}}
    nsp = deepcopy(state.ns)  # number of samples subtended by each population

    for s in migration_sets1:
        if isinstance(s, str):
            # 1d lifting
            pop = s
            nv = state.axes[pop] - 1
            assert nv == sum(
                state.ns[pop].values()
            )  # the dimension of the child axes should match what is tracked by ns
            # without migration, the number of subtended leaf lineages does not change
            # print(pop, nv)
            aux["mats"][pop,] = aux_single(nv)
        else:
            # lifting with multiple populations
            involved = tuple(set(it.chain.from_iterable(s)))
            cmm = lift_cm_aux(state.axes, s)
            aux["mats"][involved] = cmm

    # set up functions for computing migration rates and pop sizes at runtime
    return state, aux


def lift(
    state: State, t0: Path, t1: Path, terminal: bool, demo: dict, aux: dict
) -> StateReturn:
    """Lift partial likelihood.

    Args:
        st: state just before the lifting event
        t0: time before the lifting event
        t1: time after the lifting event
        terminal: does lift go to infinity?
        demo: dict of parameters
        aux: dict of auxiliary data generated by setup

    Returns:
        State after the lifting event.
    """
    etas = util.coalescent_rates(demo)
    mu = partial(util.migration_rate, demo)

    t0 = jnp.array(get_path(demo, t0))
    t1 = jnp.array(get_path(demo, t1))
    plp = state.pl
    phip = 0.0

    for pops in aux["mats"]:
        # add branch length subtended
        inds = {pop: 0 for pop in plp.named_axes}
        for pop in pops:
            inds[pop] = slice(None)
        pl0 = state.pl[inds].squeeze()

        if len(pops) == 1:
            (pop,) = pops
            mats = aux["mats"][pop,]
            if mats is None:
                # the population has 0 tracked lineages
                assert pl0.named_axes == {pop: 1}
                continue

            @pz.nx.nmap
            def f(pl):
                return _lift1(
                    pl,
                    etas[pop],
                    t0,
                    t1,
                    mats["d"],
                    mats["Q"],
                    mats["M"],
                    mats["QQ"],
                    mats["RR"],
                    mats["W"],
                    terminal,
                )

            etbl, _ = etbl_R(etas[pop], t0, t1, mats["W"])
            etbl = pz.nx.wrap(etbl)
        else:

            @pz.nx.nmap
            def f(pl, etbl=False):
                pl = pz.nx.wrap(pl, *pops)
                return lift_cm(pl, t0, t1, etas, mu, demo, aux["mats"][pops], etbl)

            etbl = f(pl0.untag(*pops), True)

        plp = f(plp.untag(*pops))
        plp = plp.tag(*pops)
        etbl = etbl.tag(*pops)
        assert pl0.named_axes.keys() == etbl.named_axes.keys()
        phip += (pl0 * etbl).unwrap(*pops).sum()
    # print(self.t1, self.t0, axes, phip)
    return state._replace(pl=plp, phi=state.phi + phip), {}


def _lift1(
    pl: Float[ArrayLike, "n"],
    eta: PExp,
    t0: ScalarLike,
    t1: ScalarLike,
    d,
    Q,
    M,
    QQ,
    RR,
    W,
    terminal,
):
    """
    Lift a partial likelihood along a single axis.
    Args:
        pl: The partial likelihood to lift
        eta: effective population size (if constant) or (N0, N1) size at the bottom/top of the branch
        t0, t1: elapsed time along branch.
        d, Q, W: precomputed matrices; see setup()
        terminal: if true, do not perform lifting

    Returns:
        pl: lifted partial likelihood
        etbl: branch length subtended by the lifted axis
    """
    # first compute phi, the total branch length. do this first because we need to mulitply by the partial likelihood at
    # the bottom.
    _, R = etbl_R(eta, t0, t1, W)
    if terminal:
        return pl
    # now compute the lifted partial likelihood
    # we basically want to contract the partial likelihood along the lifted axis with the matrix
    # Q * exp(d * R) * Qinv. however for numerical & computational reasons, avoid matrix-matrix products or inversion
    if True:
        exp_d = jnp.exp(R * d)
        plp = jnp.linalg.solve(Q, exp_d * (Q @ pl))
    return plp


def etbl_R(
    eta: PExp, t0: ScalarLike, t1: ScalarLike, W: Float[ArrayLike, "n n"]
) -> tuple[Float[ArrayLike, "n+2"], ScalarLike]:
    """Total branch length subtended by the lifted axis.

    Args:
        Ne: starting/ending population size
        tau: elapsed time

    Returns:
       Expected branch length subtending j=2, ..., n lineages.
    """
    # N1 = N0 * exp(-g * tau) => g = -log(N1 / N0) / tau
    n = W.shape[0] + 1
    assert W.shape == (n - 1, n - 1)
    j = jnp.arange(2, n + 1)
    jC2 = j * (j - 1) / 2.0
    R = eta.R(t1) - eta.R(t0)
    etjj = vmap(eta.exp_integral, (None, None, 0))(t0, t1, jC2)
    fn = W @ etjj
    k = j - 1
    e_tmrca_min_tau = ((k / n) * fn).sum()
    # now compute the remaining branch lengths
    tau = t1 - t0
    etbl = jnp.r_[0, fn, jnp.where(jnp.isinf(tau), 0, tau - e_tmrca_min_tau)]
    return etbl, R


# utility matrices


@lru_cache(None)
def W_matrix(n: Int[ScalarLike, ""]) -> Float[ArrayLike, "{n-1} {n-1}"]:
    # n should be castable to int. otherwise mpq() constructor will fail.
    n = int(n)
    # returns W matrix as calculated as eq 13:15 @ Polanski 2013
    # n: sample size
    if n == 1:
        return np.empty([0, 0])  # satisfy type checker
    W = np.zeros(
        [n - 1, n - 1], dtype=object
    )  # indices are [b, j] offset by 1 and 2 respectively
    W[:, 2 - 2] = mpq(6, n + 1)
    if n == 2:
        return W.astype(float)
    b = list(range(1, n))
    W[:, 3 - 2] = np.array([mpq(30 * (n - 2 * bb), (n + 1) * (n + 2)) for bb in b])
    for j in range(2, n - 1):
        A = mpq(-(1 + j) * (3 + 2 * j) * (n - j), j * (2 * j - 1) * (n + j + 1))
        B = np.array([mpq((3 + 2 * j) * (n - 2 * bb), j * (n + j + 1)) for bb in b])
        W[:, j + 2 - 2] = A * W[:, j - 2] + B * W[:, j + 1 - 2]
    return W.astype(float)


@lru_cache(None)
def rate_matrix(n, sparse_format="csr"):
    # returns moran rate matrix (from momi2)
    # n: sample size
    i = np.arange(n + 1)
    diag = i * (n - i) / 2.0
    diags = [diag[:-1], -2 * diag, diag[1:]]
    M = scipy.sparse.diags(diags, [1, 0, -1], (n + 1, n + 1), format=sparse_format)
    return M.T


@lru_cache(None)
def moran_eigensystem(n):
    # returns eigen decomp of rate matrix (from momi2)
    # n: sample size
    M = rate_matrix(n).toarray()
    d, Q = np.linalg.eig(M)
    return d, Q.T
