from functools import partial
from typing import Callable

import diffrax as dfx
import equinox as eqx
import jax
import jax.numpy as jnp
from jaxtyping import Array, Float, ScalarLike
from loguru import logger

import demesinfer.util as util

from .bounded_solver import BoundedSolver
from .interp import ODEInterpolator
from .state import State, StateReturn


def lift_migration_const(
    state: State,
    t0: ScalarLike,
    t1: ScalarLike,
    terminal: bool,
    demo: dict,
    aux: dict,
    C: Float[Array, "..."],
):
    logger.debug("Constant size with migration not implemented yet.")
    return lift_migration(state, t0, t1, terminal, demo, aux, C)


def _ode(t, y, args):
    state, demo, C = args
    n = state.p.ndim
    mu = partial(util.migration_rate, demo)
    etas = util.coalescent_rates(demo)

    def rate(t):
        eta = jnp.array([1 / 2 / etas[pop](t) for pop in state.pops])
        eta = jnp.append(eta, 0.0)
        return C.dot(eta)

    # migration matrix at time t
    M_t = jnp.array([[mu(dest, src, t) for dest in state.pops] for src in state.pops])
    M_t = jnp.pad(M_t, ((0, 1), (0, 1)), constant_values=0.0)  # add untracked deme
    M_t = M_t - jnp.diag(M_t.sum(axis=1))  # make it a stochastic matrix
    # transition p forward in time
    p, s = y
    ds = p * rate(t)
    # multiply along each axis, equivalent of direct sum
    dp = sum(
        map(
            lambda i: jnp.apply_along_axis(M_t.T.__matmul__, i, p),
            range(n),
        )
    )
    # movement into coalescent state
    dp -= ds  # movement among migrant states, independent
    return dp, ds.sum()


def lift_migration(
    state: State,
    t0: ScalarLike,
    t1: ScalarLike,
    terminal: bool,
    demo: dict,
    aux: dict,
    C: Float[Array, "..."],
) -> StateReturn:
    """Lift partial likelihood.

    Args:
        st: state just before the lifting event
        demo: dict of parameters
        aux: dict of auxiliary data generated by setup

    Returns:
        State after the lifting event.
    """
    aux = aux or {}
    args = (state, demo, C)

    etas = util.coalescent_rates(demo)

    eta_ts = jnp.concatenate([eta.t[:-1] for eta in etas.values()])
    mu_ts = jnp.array(
        [m.get(x, t0) for m in demo["migrations"] for x in ("start_time", "end_time")]
    )
    jump_ts = jnp.concatenate([eta_ts, mu_ts])
    jump_ts = jnp.sort(jump_ts)
    saveat = dfx.SaveAt(dense=True, t1=True)
    # FIXME using jump_ts causes nans to be returned
    ssc = dfx.PIDController(rtol=1e-8, atol=1e-8, jump_ts=jump_ts)
    y0 = (state.p, 0.0)

    # if f has error, this will throw more comprehensibly than doing it inside of diffeqsolve
    _ = _ode(t0, y0, args)

    term = dfx.ODETerm(_ode)

    def oob_fn(y):
        p, s = y
        return jnp.any(p < 0) | jnp.any(p > 1) | (s < 0) | (s > 1)

    solver = BoundedSolver(oob_fn=oob_fn)
    sol = dfx.diffeqsolve(
        term,
        solver,
        t0=t0,
        t1=t1,
        dt0=(t1 - t0) / 1000.0,
        args=args,
        y0=y0,
        stepsize_controller=ssc,
        saveat=saveat,
        max_steps=4096,
    )
    p1 = sol.ys[0][0]
    s1 = sol.ys[1][0]
    p1 = p1 / p1.sum()  # normalize to probability conditional on non-coalescence

    # interp interpolates from the "bottom" state up to t \in [t0, t1]
    interp = ODEInterpolator(sol=sol, state=state, t0=t0, t1=t1, C=C, jump_ts=jump_ts)

    # state update come *after* interp is created
    state = state._replace(
        p=p1,
        log_s=state.log_s + jnp.log1p(-s1),
    )

    return state, {"lift": interp}
