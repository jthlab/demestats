from dataclasses import dataclass

import jax
import jax.numpy as jnp
from penzai import pz

from .. import events as base
from .state import StateNd as State

NoOp = base.NoOp
Epoch = base.Epoch


@dataclass(kw_only=True)
class PopulationStart(base.PopulationStart):
    pass


# convolve over donor and recipient axes, keep recipient axis
@pz.nx.nmap
def split1_helper(P):
    n = P.shape[0]
    assert P.shape == (n, n)
    Pf = jnp.fliplr(P)

    def g(k):
        return jnp.trace(Pf, offset=k)

    return jax.vmap(g)(jnp.arange(n))[::-1]


@dataclass(kw_only=True)
class Split1(base.Split1):
    def __call__(self, demo: dict, aux: dict, child_state: State) -> tuple[State, dict]:
        """Merge two populations in same event blocks.

        Args:
            st: state just before the merge event
            demo: dict of parameters
            aux: dict of auxiliary data generated by setup
        """
        pops = child_state.pops
        assert self.donor in pops
        assert self.recipient in pops

        # convolve over donor and recipient axes, keep recipient axis
        p_prime = child_state.p.untag(self.donor, self.recipient)
        p_prime = split1_helper(p_prime)
        p_prime = p_prime.tag(self.recipient)
        return State(p=p_prime, log_s=child_state.log_s), {}


@dataclass(kw_only=True)
class Split2(base.Split2):
    def __call__(
        self, demo: dict, aux: dict, donor_state: State, recipient_state: State
    ) -> tuple[State, dict]:
        """Merge two populations in different event blocks.

        Args:
            st: state just before the merge event
            demo: dict of parameters
            aux: dict of auxiliary data generated by setup
        """
        n = donor_state.p.named_shape[self.donor]
        assert recipient_state.p.named_shape[self.recipient] == n

        @pz.nx.nmap
        def f(donor_col, recip_col):
            return jnp.convolve(donor_col, recip_col, mode="full")[:n]

        pd = donor_state.p.untag(self.donor)
        pr = recipient_state.p.untag(self.recipient)
        p_prime = f(pd, pr).tag(self.recipient)

        return State(
            p=p_prime,
            log_s=donor_state.log_s + recipient_state.log_s,
        ), {}


@dataclass(kw_only=True)
class Merge(base.Merge):
    def __call__(
        self, demo: dict, aux: dict, pop1_state: State, pop2_state: State
    ) -> tuple[State, dict]:
        # pops must be disjoint
        assert pop1_state.p.named_axes.keys().isdisjoint(pop2_state.p.named_axes.keys())
        ax1 = list(pop1_state.p.named_axes)
        ax2 = list(pop2_state.p.named_axes)
        n = pop1_state.p.named_axes[ax1[0]]
        assert all(pop1_state.p.named_axes[a] == n for a in ax1)
        assert all(pop2_state.p.named_axes[a] == n for a in ax2)
        p_prime = pop1_state.p * pop2_state.p
        return State(
            p=p_prime,
            log_s=pop1_state.log_s + pop2_state.log_s,
        ), {}


@dataclass(kw_only=True)
class MigrationStart(base.MigrationStart):
    def __call__(self, demo: dict, aux: dict, child_state: State) -> tuple[State, dict]:
        return child_state, {}


@dataclass(kw_only=True)
class MigrationEnd(base.MigrationEnd):
    def __call__(self, demo: dict, aux: dict, child_state: State) -> tuple[State, dict]:
        return child_state, {}


@pz.nx.nmap
def admix_helper(p, prob):
    "split population trailing population into populations k1 and k2"
    n = len(p)
    n, j, k = jnp.ogrid[:n, :n, :n]
    B = jax.scipy.stats.binom.pmf(j, n, prob)
    valid = n == j + k
    return jnp.einsum("n,njk,njk->jk", p, B, valid)


@dataclass(kw_only=True)
class Admix(base.Admix):
    def __call__(self, demo: dict, aux: dict, child_state: State) -> tuple[State, dict]:
        p_admix = self.prop_fun(demo)
        p_prime = child_state.p.untag(self.child)
        p_prime = admix_helper(p_prime, p_admix)
        p_prime = p_prime.tag(self.parent1, self.parent2)
        return State(p=p_prime, log_s=child_state.log_s), {}


@dataclass(kw_only=True)
class Pulse(base.Pulse):
    def __call__(self, demo: dict, aux: dict, child_state) -> tuple[State, dict]:
        p_pulse = self.prop_fun(demo)
        n = child_state.n
        # p'[i,j] = \sum_{u,v,w} p[u,v] * binom(w; u, p) * (u - w == i) * (v + w == j)
        i, u, w = jnp.ogrid[: n + 1, : n + 1, : n + 1]
        B = jax.scipy.stats.binom.pmf(w, u, p_pulse)[0]  # strip i dimension
        uwi = u - w == i

        @pz.nx.nmap
        def f(P):
            return jnp.einsum("uv,uw,iuw,vjw->ij", P, B, uwi, uwi)

        pu = child_state.p.untag(self.dest, self.source)
        p_prime = f(pu).tag(self.dest, self.source)

        return State(p=p_prime, log_s=child_state.log_s), {}
