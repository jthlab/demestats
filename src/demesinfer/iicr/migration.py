from functools import partial

import diffrax as dfx
import equinox as eqx
import jax
import jax.numpy as jnp
import numpy as np
import sparse
from jax.experimental.sparse import BCOO, sparsify
from jaxtyping import Array, Float, ScalarLike
from loguru import logger
from penzai import pz

import demesinfer.util as util

from ..bounded_solver import BoundedSolver
from . import migration_dn
from .interp import Interpolator
from .state import StateNd as State
from .state import StateReturn


class ODEInterpolator(Interpolator):
    jump_ts: Float[Array, "..."]
    sol: dfx.Solution
    C: pz.nx.NamedArray

    def jumps(self, demo):
        return self.jump_ts

    def _rate(self, t, demo):
        etas = util.coalescent_rates(demo)
        eta = jnp.array([1 / 2 / etas[pop](t) for pop in self.state.pops])
        return self.C.untag("n").dot(eta)

    def __call__(self, t, demo):
        y = self.sol.evaluate(jnp.clip(t, self.t0, self.t1))
        p, s = y
        p /= p.unwrap(*self.state.pops).sum()
        R = self._rate(t, demo)
        c = (p * R).unwrap(*self.state.pops).sum()
        return dict(c=c, log_s=self.state.log_s + jnp.log1p(-s), p=p)


def lift_migration_const(
    state: State,
    t0: ScalarLike,
    t1: ScalarLike,
    terminal: bool,
    demo: dict,
    aux: dict,
):
    logger.debug("Constant size with migration not implemented yet.")
    return lift_migration(state, t0, t1, terminal, demo, aux)


def _mats(d, n):
    B = np.array(list(np.ndindex((n + 1,) * d))).reshape((n + 1,) * d + (d,))
    # construct a tensor D[i1,...,id,j1,...,jd] = 1 if |i-j| = 1, 0 otherwise
    c1 = B[(...,) + (None,) * d + (slice(None),)]
    c2 = B
    # Neighborhood tensor
    N1 = np.abs(c1 - c2).sum(-1) == 2
    N2 = c1.sum(-1) == c2.sum(-1)
    N = N1 & N2
    # X[i,j,u,v] = 1 if iu == jv - 1, 0 otherwise
    X = c1 == c2 - 1
    # Y[i,j,u,v] = 1 if iu == jv + 1, 0 otherwise
    Y = c1 == c2 + 1

    # net rate of transition into state i=(i1,...,id) is
    # \sum_{j\in N(i)} p[j] \sum_{u,v} ju M[u,v] 1{ju == iu + 1, jv == iv - 1}
    # = \sum_{j\in N(i)} p[j] \sum_{u,v} B[j,u] M[u,v] X[i,j,u] Y[i,j,v]
    # = \sum_{j,u,v} p[j] N[i,j] B[j,u] M[u,v] X[i,j,u] Y[i,j,v]
    # = \sum_{j,u,v} p[j] M[u, v] U[i,j,u,v] where U[i,j,u,v] = N[i,j] B[j,u] X[i,j,u] Y[i,j,v]
    # find nonzero inds of U[i,j,u,v] = N[i,j] B[j,u] X[i,j,u] Y[i,j,v]
    with jax.ensure_compile_time_eval():
        N, X, Y = map(BCOO.fromdense, (N, X, Y))
        U = N[..., None, None] * X[..., :, None] * Y[..., None, :]
        U = U.sum_duplicates()
    # nz_inds = U.nonzero()
    # U_i = nz_inds[0:d]
    # U_j = nz_inds[d : 2 * d]
    # U_u = nz_inds[2 * d]
    # U_v = nz_inds[2 * d + 1]
    # construct U such that every i has the same number of nonzero entries?
    # net rate of transition into state i=(i1,...,id) is
    return dict(B=B, N=N, X=X, Y=Y, U=U)


def _ode(t, y, args):
    p, s = y
    state, demo, mats = args
    pops = state.pops
    mu = partial(util.migration_rate, demo)
    etas = util.coalescent_rates(demo)

    B = mats["B"]
    C = B * (B - 1) / 2

    def rate(t):
        eta = jnp.array([1 / 2 / etas[pop](t) for pop in pops])
        r = C.dot(eta)
        return pz.nx.wrap(r, *pops)

    # migration matrix at time t
    M_t = jnp.array([[mu(dest, src, t) for dest in state.pops] for src in state.pops])
    # M_t = M_t - jnp.diag(M_t.sum(axis=1))  # make it a stochastic matrix

    ds = p * rate(t)
    pu = p.unwrap(*pops)

    # \sum_{j,u,v} p[j] N[i,j] B[j,u] M[u,v] X[i,j,u] Y[i,j,v]
    # find nonzero inds of U[i,j,u,v] = N[i,j] B[j,u] X[i,j,u] Y[i,j,v]

    @sparsify
    def f(U):
        d = state.d
        i = tuple(range(d))
        j = tuple(range(d, 2 * d))
        u = 2 * d + 1
        v = 2 * d + 2
        return jnp.einsum(
            pu,
            j,
            U,
            i + j + (u, v),
            # N, i + j,
            B,
            j + (u,),
            # X, i + j + (u,),
            # Y, i + j + (v,),
            M_t,
            (u, v),
            i,
        )

    N = mats["N"]
    X = mats["X"]
    Y = mats["Y"]
    U = N[..., None, None] * X[..., :, None] * Y[..., None, :]
    dp_in = f(U)
    dp_in = pz.nx.wrap(dp_in, *pops)
    #   B[j1,...,jd,u] = ju for u=1,...,d
    d = state.d
    i = tuple(range(d))
    dp_out = jnp.einsum(pu, i, B, i + (d + 1,), M_t, (d + 1, d + 2), i)
    dp_out = pz.nx.wrap(dp_out, *pops)
    dp = dp_in - dp_out
    # movement into coalescent state
    dp -= ds  # movement among migrant states, independent
    return dp, ds.unwrap(*pops).sum()


def lift_migration(
    state: State,
    t0: ScalarLike,
    t1: ScalarLike,
    terminal: bool,
    demo: dict,
    aux: dict,
) -> StateReturn:
    """Lift partial likelihood.

    Args:
        st: state just before the lifting event
        demo: dict of parameters
        aux: dict of auxiliary data generated by setup

    Returns:
        State after the lifting event.
    """
    aux = aux or {}

    d = state.d
    n = state.n

    if n < d:  # d**n < n**d
        logger.debug("switching to dual migration lifting")
        pops = state.pops
        p_nd = state.p.unwrap(*pops)
        p_dn = migration_dn.nd_to_dn(p_nd)
        state_dn = migration_dn.State(p=p_dn, pops=pops, log_s=state.log_s)
        state_dn_prime, d = migration_dn.lift_migration(
            state_dn, t0, t1, terminal, demo, aux
        )
        p_dn_prime = state_dn_prime.p
        p_nd_prime = migration_dn.dn_to_nd(p_dn_prime)
        p_prime = pz.nx.wrap(p_nd_prime, *pops)
        state = state._replace(p=p_prime, log_s=state_dn_prime.log_s)
        return state, d

    mats = _mats(state.d, state.n)
    C = mats["B"] * (mats["B"] - 1) / 2
    C = pz.nx.wrap(C, *state.pops, "n")

    args = (state, demo, mats)
    etas = util.coalescent_rates(demo)
    eta_ts = jnp.concatenate([eta.t[:-1] for eta in etas.values()])
    mu_ts = jnp.array(
        [m.get(x, t0) for m in demo["migrations"] for x in ("start_time", "end_time")]
    )
    jump_ts = jnp.concatenate([eta_ts, mu_ts])
    jump_ts = jnp.sort(jump_ts)
    saveat = dfx.SaveAt(dense=True, t1=True)

    ssc = dfx.PIDController(rtol=1e-8, atol=1e-8, jump_ts=jump_ts)
    y0 = (state.p, 0.0)

    # if f has error, this will throw more comprehensibly than doing it inside of diffeqsolve
    _ = _ode(t0, y0, args)

    term = dfx.ODETerm(_ode)

    def oob_fn(y):
        p, s = y
        p = p.unwrap(*state.pops)
        return jnp.any(p < 0) | jnp.any(p > 1) | (s < 0) | (s > 1)

    solver = BoundedSolver(oob_fn=oob_fn)
    sol = dfx.diffeqsolve(
        term,
        solver,
        t0=t0,
        t1=t1,
        dt0=(t1 - t0) / 1000.0,
        args=args,
        y0=y0,
        stepsize_controller=ssc,
        saveat=saveat,
        max_steps=4096,
    )
    p1 = sol.ys[0][0]
    s1 = sol.ys[1][0]
    p1 = (
        p1 / p1.unwrap(*state.pops).sum()
    )  # normalize to probability conditional on non-coalescence

    # interp interpolates from the "bottom" state up to t \in [t0, t1]
    interp = ODEInterpolator(sol=sol, state=state, t0=t0, t1=t1, C=C, jump_ts=jump_ts)

    # state update come *after* interp is created
    state = state._replace(
        p=p1,
        log_s=state.log_s + jnp.log1p(-s1),
    )

    return state, {"lift": interp}
