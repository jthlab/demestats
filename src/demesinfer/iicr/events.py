from dataclasses import dataclass
from functools import partial, reduce

import diffrax as dfx
import equinox as eqx
import jax
import jax.numpy as jnp
import numpy as np
from jaxtyping import Array, Float, Scalar, ScalarLike
from loguru import logger
from penzai import pz

import demesinfer.events as base
import demesinfer.util as util
from demesinfer.path import Path, get_path

from .interp import PanmicticInterpolator
from .migration import lift_migration, lift_migration_const
from .state import SetupReturn, StateReturn
from .state import StateNd as State

NoOp = base.NoOp
Epoch = base.Epoch


def setup_lift(
    state: None, t0: Path, t1: Path, terminal: bool, aux: dict, demo: dict
) -> tuple[None, dict]:
    const = dict(util.constant_growth_in(demo, t0, t1))
    migr = list(util.migrations_in(demo, t0, t1))
    return None, dict(const=const, migrations=migr)


def lift(
    state: State, t0: Path, t1: Path, terminal: bool, demo: dict, aux: dict
) -> StateReturn:
    """Lift partial likelihood.

    Args:
        state: state just before the lifting event
        t0: time before the lifting event
        t1: time after the lifting event
        terminal: does lift go to infinity?
        demo: dict of parameters
        aux: dict of auxiliary data generated by setup

    Returns:
        State after the lifting event.
    """
    logger.debug("lift: state={} t0={} t1={} terminal={}", state, t0, t1, terminal)
    t0 = jnp.array(get_path(demo, t0))
    t1 = jnp.array(get_path(demo, t1))
    active_migr = [m for m in aux["migrations"] if set(m) & set(state.pops)]

    if len(active_migr) == 0 or terminal:
        n = state.n
        d = state.d
        B = np.array(list(np.ndindex((n + 1,) * d))).reshape((n + 1,) * d + (d,))
        C = pz.nx.wrap(B * (B - 1) / 2, *state.pops, "n")
        interp = PanmicticInterpolator(state=state, t0=t0, t1=t1, C=C)
        with jax.debug_nans(False):
            d1 = interp(t1, demo)
        state = state._replace(log_s=d1["log_s"], p=d1["p"])
        return state, {"lift": interp}

    const = all(aux["const"].get(p, False) for p in state.pops)
    lm = lift_migration_const

    if not const:
        logger.info(
            "Using ODE solver for migration and non-constant size. This may be slow."
        )
        lm = lift_migration

    return lm(state, t0, t1, terminal, demo, aux)


@dataclass(kw_only=True)
class PopulationStart(base.PopulationStart):
    pass


@dataclass(kw_only=True)
class Split1(base.Split1):
    def __call__(self, demo: dict, aux: dict, child_state: State) -> StateReturn:
        """Merge two populations in same event blocks.

        Args:
            st: state just before the merge event
            demo: dict of parameters
            aux: dict of auxiliary data generated by setup
        """
        pops = child_state.pops
        assert self.donor in pops
        assert self.recipient in pops

        # convolve over donor and recipient axes, keep recipient axis
        @pz.nx.nmap
        def f(P):
            n = P.shape[0]
            assert P.shape == (n, n)
            Pf = jnp.fliplr(P)

            def g(k):
                return jnp.trace(Pf, offset=k)

            return jax.vmap(g)(jnp.arange(n))[::-1]

        p_prime = f(child_state.p.untag(self.donor, self.recipient)).tag(self.recipient)
        return child_state._replace(p=p_prime), {}


@dataclass(kw_only=True)
class Split2(base.Split2):
    def __call__(
        self, demo: dict, aux: dict, donor_state: State, recipient_state: State
    ) -> StateReturn:
        """Merge two populations in different event blocks.

        Args:
            st: state just before the merge event
            demo: dict of parameters
            aux: dict of auxiliary data generated by setup
        """
        n = donor_state.p.named_shape[self.donor]
        assert recipient_state.p.named_shape[self.recipient] == n

        @pz.nx.nmap
        def f(donor_col, recip_col):
            return jnp.convolve(donor_col, recip_col, mode="full")[:n]

        pd = donor_state.p.untag(self.donor)
        pr = recipient_state.p.untag(self.recipient)
        p_prime = f(pd, pr).tag(self.recipient)

        return State(
            p=p_prime,
            log_s=donor_state.log_s + recipient_state.log_s,
        ), {}


@dataclass(kw_only=True)
class Merge(base.Merge):
    def __call__(
        self, demo: dict, aux: dict, pop1_state: State, pop2_state: State
    ) -> StateReturn:
        # pops must be disjoint
        assert pop1_state.p.named_axes.keys().isdisjoint(pop2_state.p.named_axes.keys())
        ax1 = list(pop1_state.p.named_axes)
        ax2 = list(pop2_state.p.named_axes)
        n = pop1_state.p.named_axes[ax1[0]]
        assert all(pop1_state.p.named_axes[a] == n for a in ax1)
        assert all(pop2_state.p.named_axes[a] == n for a in ax2)
        p_prime = pop1_state.p * pop2_state.p
        return State(
            p=p_prime,
            log_s=pop1_state.log_s + pop2_state.log_s,
        ), {}


@dataclass(kw_only=True)
class MigrationStart(base.MigrationStart):
    def __call__(self, demo: dict, aux: dict, child_state: State) -> StateReturn:
        return child_state, {}


@dataclass(kw_only=True)
class MigrationEnd(base.MigrationEnd):
    def __call__(self, demo: dict, aux: dict, child_state: State) -> StateReturn:
        return child_state, {}


@dataclass(kw_only=True)
class Admix(base.Admix):
    def __call__(self, demo: dict, aux: dict, child_state: State) -> StateReturn:
        p_admix = self.prop_fun(demo)
        # child splits into self.parent1 and self.parent2
        pops = list(child_state.pops)
        i = pops.index(self.child)
        pops.pop(i)
        pops.extend([self.parent1, self.parent2])
        n = len(pops)
        p_prime = _split(child_state.p, i, n - 2, n - 1, p_admix)
        return child_state._replace(p=p_prime, pops=tuple(pops)), {}


@dataclass(kw_only=True)
class Pulse(base.Pulse):
    def __call__(self, demo: dict, aux: dict, child_state) -> StateReturn:
        p_pulse = self.prop_fun(demo)
        pops = child_state.pops
        n = child_state.n
        # p'[i,j] = \sum_{u,v,w} p[u,v] * binom(w; u, p) * (u - w == i) * (v + w == j)
        i, u, w = jnp.ogrid[: n + 1, : n + 1, : n + 1]
        B = jax.scipy.stats.binom.pmf(w, u, p_pulse)[0]  # strip i dimension
        uwi = u - w == i

        @pz.nx.nmap
        def f(P):
            return jnp.einsum("uv,uw,iuw,vjw->ij", P, B, uwi, uwi)

        pu = child_state.p.untag(self.dest, self.source)
        p_prime = f(pu).tag(self.dest, self.source)

        return child_state._replace(p=p_prime), {}
